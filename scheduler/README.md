# CENG 301 - CPU Process Scheduling Simulator

**Student Name:** Umut Ã–zcan  
**Student ID:** 230205016  
**Section:** 1  
**Course:** CENG 301 - Operating Systems  

## 1. Project Overview
This is a modular CPU Scheduling Simulator built in Python 3. It simulates how different scheduling algorithms manage processes and calculates important performance metrics like waiting time, turnaround time, and response time .

## 2. Requirements
* **Python Version:** Python 3.x
* **Libraries:** You need the `matplotlib` library for the comparison graphs.
  ```bash
  pip install matplotlib

## 3. Project Structure
I organized the project in a modular way to keep the code clean and easy to follow :

* **algorithms/**: Contains the implementation for all six required scheduling algorithms (FCFS, SJF, SRTF, RR, and Priority NP/P).
* **utils/**: Holds common helper scripts like the file parser, the process object class, and the Gantt chart renderer.
* **graphs/**: This folder is used to store the `.png` charts generated after running the comparison script.
* **scheduler.py**: The main script that takes command-line arguments and executes the chosen algorithm.
* **compare.py**: A script used to run every algorithm on the same workload to compare their efficiency .
* **processes.txt**: The input text file containing process IDs, arrival times, burst times, and priorities .
* **README.md**: Project documentation, instructions, and observation reports.

## 4. How to Run the Simulator
You can run the simulator through the terminal.

### 1. Run a single algorithm:
To see the results and Gantt chart for one specific algorithm, use `scheduler.py` with these arguments:
Example: Running Round Robin with a quantum of 4 
python scheduler.py --input processes.txt --algo RR --quantum 4
### 2. Run the comparison tool:
If you want to run every algorithm at once, see the comparison table, and generate the graphs in the graphs/ folder, run this :
python compare.py

## 5. Algorithm Descriptions
I implemented the following six CPU scheduling algorithms as required by the project:

1. **FCFS (First-Come First-Served):** This is the simplest one where processes are handled in the order they arrive. It is non-preemptive.
2. **SJF (Shortest Job First):** A non-preemptive algorithm that always picks the process with the shortest burst time from the ready queue.
3. **SRTF (Shortest Remaining Time First):** This is the preemptive version of SJF. It constantly checks if a new process has a shorter remaining time than the current one and switches if necessary.
4. **Round Robin (RR):** Each process gets a small, fixed amount of CPU time called a "quantum". If the process doesn't finish in that time, it goes to the back of the queue.
5. **Priority Scheduling (Non-preemptive):** Processes are executed based on their priority level. Higher priority processes (lower numerical values) go first.
6. **Priority Scheduling (Preemptive):** Similar to the non-preemptive version, but if a higher-priority process arrives, it will preempt (interrupt) the current process immediately.

## 6. Observations and Discussion 
After running all the algorithms with the same `processes.txt` workload, here are my thoughts and results:

* **Best Performer:** In my tests, **SRTF (Shortest Remaining Time First)** usually performed the best because it consistently had the lowest "Average Waiting Time". This makes sense because it always prioritizes the shortest job, preventing long tasks from blocking the CPU for too long.
* **Context Switch Count:** I noticed a big difference in context switches.Non-preemptive algorithms like **FCFS** and **SJF** have very few switches, while preemptive ones like **Round Robin** and **SRTF** have many more because they frequently interrupt processes.
* **Round Robin (RR) Behavior:** Round Robin is very fair for all processes, but I observed that if the **time quantum** is set too low, the number of context switches jumps significantly, which can make the system inefficient.
* **Priority Starvation:** In the **Priority Scheduling** tests, I saw that if high-priority tasks keep arriving, low-priority tasks (like those with higher numerical priority values) have to wait a very long time to get CPU time.
* **Tie-Breaking:** Using the **PID** to break ties (when arrival times or burst times are equal) was very helpful to keep the simulation deterministic and the results consistent as required.

## 7. Github Link
I also uploaded the whole project to GitHub:  
https://github.com/UmutOZCN/CENG-301-CPU-Process-Scheduling-Simulator

The repository includes:
* **Algorithms:** The 6 CPU scheduling algorithms I implemented for this project.
* **Tools:** My helper scripts for parsing input and rendering the Gantt chart.
* **Results:** The comparison table and the graphs generated by the simulator.